Propuesta: Minimizar lecturas de Sheets y Particionamiento lógico de datos (GAS)

Objetivo

Reducir latencia y consumo de cuotas de Google Sheets.

Evitar leer “todo” y mover el peso de cómputo al momento de escritura y a cachés rápidos.

Mantener consultas rápidas para “recientes” y escalables para históricos.

1) Minimizar lecturas de Sheets

Principios

Leer solo lo necesario: columnas y filas estrictamente requeridas.

Preferir “últimos N” y rangos fijos en vez de recorrer toda la hoja.

Precalcular e indexar en la escritura (materializar vistas de consulta frecuente).

Cachear resultados y metadatos (última fila, índices) en CacheService.

Técnicas concretas

Proyección de columnas (solo las necesarias)

function readProjectedRange_(sheet, startRow, numRows) {
  // Ejemplo: columnas A:I (9 col), ajusta a tus cabeceras reales
  const lastCol = 9;
  return sheet.getRange(startRow, 1, numRows, lastCol).getValues();
}

Ventana móvil de “últimos N”

function readLastN_(sheet, N) {
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return [];
  const headerRow = 1;
  const startRow = Math.max(headerRow + 1, lastRow - N + 1);
  const numRows = lastRow - startRow + 1;
  return readProjectedRange_(sheet, startRow, numRows);
}

Rango por fecha (datos ordenados por inserción)

function findRowBoundsByDate_(values, dateColIndex, from, to) {
  const res = [];
  for (let i = values.length - 1; i >= 0; i--) {
    const d = new Date(values[i][dateColIndex]);
    if (d >= from && d <= to) res.push(values[i]);
    if (d < from) break;
  }
  return res.reverse();
}

Índices en memoria/caché

Mantén un índice ligero { vendedor → [rowPointers] } con hoja, fila y fecha.

Actualízalo al insertar un registro y guárdalo en CacheService (y sombra en PropertiesService).

Para búsquedas por cliente o vendedor, obtén punteros y usa batchGet para leer solo esas filas.

Vistas materializadas “Últimos N por vendedor”

Hoja LN_{VEND} que almacena los N registros más recientes.

Actualízala en cada escritura; las consultas “recientes” leen solo esa hoja.

Lotes en una sola llamada

getRangeList(['A2:I101','A205:I305'])
  .getRanges()
  .map(r=>r.getValues());

O con Sheets Advanced Service:

Sheets.Spreadsheets.values.batchGet({...});

Evita getDisplayValues() salvo para UI

Usa getValues() y formatea en cliente/plantilla.

Metadata en caché

Cachea lastRow, mapeo de cabeceras y nombres de pestañas.

Invalida o actualiza solo al escribir, no en cada lectura.

2) Particionamiento lógico de datos

Actualizado según la documentación más reciente de Google Apps Script, MDN y principios SOLID.

Estrategias de partición

Por mes/añoHojas REG_YYYY_MM (por ejemplo, REG_2025_09). Tamaño acotado; consultas “recientes” en la partición activa. Rango > 1 mes → 1–3 hojas.

Por vendedorHojas V_<CÓDIGO>_YYYY_MM (por ejemplo, V_001_2025_09). Paraleliza operaciones; reduce contención.

Por banco receptorHojas B_<BANCO>_YYYY_MM (por ejemplo, B_Banesco_2025_09). Facilita la conciliación bancaria al agrupar pagos por receptor.

Híbrido (mes + vendedor)Hojas V_<CÓDIGO>_YYYY_MM. Útil si el volumen mensual por vendedor supera umbrales de Sheets. Extensible a “mes + banco” o “mes + vendedor + banco”.

Cada estrategia aplica SOLID:

Single Responsibility: funciones dedicadas a calcular nombres o crear hojas.

Open/Closed: nuevas particiones extienden el router sin modificarlo.

Liskov Substitution: cada estrategia actúa como una “strategy” intercambiable.

Interface Segregation: separación de lógica de partición y lógica de lectura/escritura.

Dependency Inversion: el módulo principal depende de la abstracción getPartitionName.

Router de particiones

/**
 * Devuelve el nombre de la partición según estrategia.
 * @param {Date} date
 * @param {Object} opts { type: 'mes'|'vendedor'|'banco'|'hibrido', vendedor?, banco? }
 */
function getPartitionName(date, { type, vendedor, banco }) {
  const yyyy = date.getFullYear();
  const mm   = String(date.getMonth() + 1).padStart(2,'0');
  switch (type) {
    case 'mes':
      return `REG_${yyyy}_${mm}`;
    case 'vendedor':
      return `V_${vendedor}_${yyyy}_${mm}`;
    case 'banco':
      return `B_${banco}_${yyyy}_${mm}`;
    case 'hibrido':
      return `V_${vendedor}_${yyyy}_${mm}`;
    default:
      throw new Error(`Tipo desconocido: ${type}`);
  }
}

function ensurePartitionSheet(ss, name, header) {
  let sh = ss.getSheetByName(name);
  if (!sh) {
    sh = ss.insertSheet(name);
    sh.getRange(1,1,1,header.length).setValues([header]);
    sh.setFrozenRows(1);
  }
  return sh;
}

Escrituras con actualización de partición e índices

/**
 * Inserta un registro y actualiza índices y vistas.
 * @param {Spreadsheet} ss
 * @param {Object} record { fechaEnvio, vendedorCodigo, bancoReceptor, … }
 * @param {string[]} header
 */
function appendRegistro(ss, record, header) {
  const fecha = new Date(record.fechaEnvio || Date.now());
  const opts  = {
    type:     decidePartitionType(record), // 'mes'|'vendedor'|'banco'|'hibrido'
    vendedor: record.vendedorCodigo,
    banco:    record.bancoReceptor
  };
  const name = getPartitionName(fecha, opts);
  const sh   = ensurePartitionSheet(ss, name, header);

  const row = header.map(h => record[h] ?? '');
  sh.appendRow(row);

  updateIndex(ss, {
    hoja:    name,
    fila:    sh.getLastRow(),
    fecha,
    vendedor: record.vendedorCodigo,
    banco:    record.bancoReceptor
  });
  updateUltimosNGlobal(ss, row, header, 100);
  updateUltimosNPorVendedor(ss, record.vendedorCodigo, row, header, 100);
}

decidePartitionType es un módulo independiente que elige la estrategia según volúmenes y contexto.

La secuencia garantiza consistencia atómica en índices y vistas.

3) Índices y Vistas materializadas

Índice (hoja IDX)

Columnas: hoja, fila, fechaISO, vendedor, cliente, factura, monto.

Al escribir, appendRow en IDX.

Para búsquedas, filtra IDX por vendedor y rango de fechas, luego usa getRangeList para leer filas exactas.

function updateIndex(ss, idxRow) {
  const sh = ensurePartitionSheet(
    ss,
    'IDX',
    ['hoja','fila','fechaISO','vendedor','cliente','factura','monto']
  );
  sh.appendRow([
    idxRow.hoja,
    idxRow.fila,
    idxRow.fecha.toISOString().slice(0,10),
    idxRow.vendedor||'',
    idxRow.cliente || '',
    idxRow.factura || '',
    idxRow.monto   || ''
  ]);
}

Vistas “LN” (últimos N)

LN_ALL: últimos N globales.

LN_{VEND}: últimos N por vendedor.

Al exceder N, elimina filas antiguas.

function updateUltimosNPorVendedor(ss, vend, row, header, N) {
  const name = `LN_${vend}`;
  const sh   = ensurePartitionSheet(ss, name, header);
  sh.appendRow(row);
  const lastRow  = sh.getLastRow();
  const dataRows = lastRow - 1;
  if (dataRows > N) {
    sh.deleteRows(2, dataRows - N);
  }
}

4) Triggers de mantenimiento

Rotación mensualCrea la partición de mes nuevo con cabecera.

Compactación de vistas LNGarantiza que cada LN_* no exceda N.

Precalentamiento de cachésRecalcula cachés “recientes” e índices a primera hora.

function rotacionMensual_() {
  const ss   = SpreadsheetApp.getActive();
  const now  = new Date();
  const name = getPartitionName(now, {type:'mes'});
  ensurePartitionSheet(ss, name, getHeader_());
}

5) Plan de migración

Definir cabecera estándar.

Implementar router de particiones.

Redirigir escrituras a la partición activa.

Crear y poblar LN_ALL y LN_{VEND} al vuelo.

Adaptar lectura de “recientes” para usar LN_*.

Implementar consulta por rango: resolver particiones y leer sólo esas hojas.

Retro-migrar históricos a hojas mensuales (script único).

Agregar triggers de rotación mensual y precalentamiento.

Medir tiempos de respuesta y lecturas; ajustar N y TTL.

6) Riesgos y mitigaciones

Complejidad de consultas跨-particiónMitigar con índice IDX y límites de fechas en UI.

Consistencia de vistas LNUsar LockService para actualizaciones atómicas si hay alta concurrencia.

Límite de hojasEvaluar particionar por archivo tras cierto umbral (por ejemplo, un spreadsheet por año).

7) Métricas y validación

Medir tiempos de

Escritura + actualización de LN/IDX.

Lectura de “recientes” y rangos típicos.

Contar lecturas de Sheets por endpoint (antes/después).

Ajustar N y columnas proyectadas según patrones de uso.

8) Checklist de adopción

[ ] Router de particiones (mes, vendedor, banco, híbrido).

[ ] Escritura en partición + actualización de LN_ALL y LN_{VEND}.

[ ] Consulta “recientes” desde LN_*.

[ ] Consulta por rango leyendo sólo particiones afectadas.

[ ] Índice IDX implementado para búsquedas combinadas.

[ ] Triggers: rotación mensual, compactación LN, precalentamiento de cachés.

[ ] Métricas básicas de rendimiento recopiladas.

Con estas prácticas, las lecturas son acotadas y predecibles. El particionamiento por mes, vendedor, banco receptor e híbrido, junto con vistas materializadas y un router flexible, garantiza escalabilidad y agilidad incluso con crecimiento sostenido de datos.